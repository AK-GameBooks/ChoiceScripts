<!DOCTYPE html>
<html>
<head>
<title>Basic ChoiceScript Editor</title>
<meta http-equiv="X-UA-Compatible" content="chrome=1">  

<!-- ***** BEGIN LICENSE BLOCK *****
- Version: MPL 1.1/GPL 2.0/LGPL 2.1
-
- The contents of this file are subject to the Mozilla Public License Version
- 1.1 (the "License"); you may not use this file except in compliance with
- the License. You may obtain a copy of the License at
- http://www.mozilla.org/MPL/
-
- Software distributed under the License is distributed on an "AS IS" basis,
- WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- for the specific language governing rights and limitations under the
- License.
-
- The Original Code is Bespin.
-
- The Initial Developer of the Original Code is
- Mozilla.
- Portions created by the Initial Developer are Copyright (C) 2009
- the Initial Developer. All Rights Reserved.
-
- Contributor(s):
-
- Alternatively, the contents of this file may be used under the terms of
- either the GNU General Public License Version 2 or later (the "GPL"), or
- the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- in which case the provisions of the GPL or the LGPL are applicable instead
- of those above. If you wish to allow use of your version of this file only
- under the terms of either the GPL or the LGPL, and not to allow others to
- use your version of this file under the terms of the MPL, indicate your
- decision by deleting the provisions above and replace them with the notice
- and other provisions required by the GPL or the LGPL. If you do not delete
- the provisions above, a recipient may use your version of this file under
- the terms of any one of the MPL, the GPL or the LGPL.
-
- ***** END LICENSE BLOCK ***** -->

<link href="BespinEmbedded.css" type="text/css" rel="stylesheet">
<script type="text/javascript" src="BespinEmbedded.js"></script>
<script src="../web/util.js"></script>
<script src="../headless.js"></script>
<script src="../web/scene.js"></script>
<script src="../web/navigator.js"></script>
<script>window.version="DEVELOPMENT"</script>
<script src="../web/mygame/mygame.js"></script>`
<script>
window.name = "editor";
function tryIt() {
  var sceneText = getContent();
  autotester(sceneText);
}

function autotester(sceneText) {
  debugger;
  function log(msg) {console.log(msg)}
  var coverage = [1];

  var printed = [];
  printx = function printx(msg, parent) {
      //printed.push(msg);
  }
    
  var sceneList = [];
  
  function debughelp() {
      debugger;
  }
  
  
  Scene.prototype.page_break = function() {};
  
  Scene.prototype.input_text = function(variable) {
      this.setVar(variable, "blah blah");
  }
  
  Scene.prototype.rollbackLineCoverage = function(lineNum) {
    if (!lineNum) lineNum = this.lineNum;
    coverage[lineNum]--;
  }
  
  Scene.prototype.__defineGetter__("lineNum", function() { return this._lineNum; });
  Scene.prototype.__defineSetter__("lineNum", function(val) {
      if (coverage[val]) {
          coverage[val]++;
      } else {
          coverage[val] = 1;
      }
      this._lineNum = val;
  });
  
  
  Scene.prototype.choice = function choice(data, fakeChoice) {
      if (data) throw new Error(this.lineMsg() + "Groups not yet supported: " + data);
      var groups = [];
      var choiceLine = this.lineNum;
      var options = this.parseOptions(this.indent, groups);
      for (var index = 0; index < options.length; index++) {
          (function (index) {
            var item = options[index];
            var scene = this.clone();
            if (fakeChoice) scene.temps.fakeChoiceEnd = this.lineNum;
            scene.testFormValues = {choice:index};
            scene.getFormValue = function(name) {return scene.testFormValues[name];}
            scene.testOptions = options;
            scene.testGroups = ["choice"];
            scene.testChoiceLine = choiceLine;
            scene.testPath.push(',');
            scene.testPath.push(choiceLine+1);
            scene.testPath.push('#');
            scene.testPath.push(index+1);
            scene.resume = function() {scene.resolveChoice(scene.testOptions, scene.testGroups);}
            sceneList.push(scene);
          }).call(this, index);
      }
      
      this.finished = true;
  }
  
  Scene.prototype.clone = function clone() {
    this.stats.scene = null;
    var clonedStats = dojoClone(this.stats);
    var scene = new Scene(this.name, clonedStats);
    scene.lines = this.lines;
    scene.labels = this.labels;
    scene.temps = dojoClone(this.temps);
    scene.loaded = true;
    scene.testPath = dojoClone(this.testPath);
    this.stats.scene = this;
    return scene;
  }
  
  function dojoClone(/*anything*/ o){
  	// summary:
  	//		Clones objects (including DOM nodes) and all children.
  	//		Warning: do not clone cyclic structures.
  	if(!o){ return o; }
  	if(o instanceof Array || typeof o == "array"){
  		var r = [];
  		for(var i = 0; i < o.length; ++i){
  			r.push(dojoClone(o[i]));
  		}
  		return r; // Array
  	}
  	if(typeof o != "object" && typeof o != "function"){
  		return o;	/*anything*/
  	}
  	if(o.nodeType && o.cloneNode){ // isNode
  		return o.cloneNode(true); // Node
  	}
  	if(o instanceof Date){
  		return new Date(o.getTime());	// Date
  	}
  	// Generic objects
  	r = new o.constructor(); // specific to dojo.declare()'d classes!
  	for(i in o){
  		if(!(i in r) || r[i] != o[i]){
  			r[i] = dojoClone(o[i]);
  		}
  	}
  	return r; // Object
  }
  
  Scene.prototype.oldGoto = Scene.prototype["goto"];
  
  var seen = {};
  Scene.prototype["goto"] = function scene_goto(label, inChoice) {
      if (inChoice) {
        this.oldGoto(label, true);
        return;
      }
      //more specific keys are better tests!
      var key = label;
      //var key = toJson(this.stats) + toJson(this.temps) + label;
      if (seen[key]) {
          //throw new Error("yay! seen!");
          this.finished = true;
          return;
      }
      seen[key] = 1;
      //log("unseen: " + key);
      this.oldGoto(label);
  }
  
  Scene.prototype.goto_scene = Scene.prototype.ending = Scene.prototype.finish;
  
  Scene.prototype.oldIf = Scene.prototype["if"];
  Scene.prototype["if"] = function test_if(line, inChoice) {
    if (inChoice) {
      this.oldIf(line);
      return;
    }
    
    // Does the expression evaluate to a boolean?
    var stack = this.tokenizeExpr(line);
    var result = this.evaluateExpr(stack);
    if ("boolean" != typeof result) {
        throw new Error(this.lineMsg() + "Invalid boolean expression; this isn't a boolean: " + result);
    }
    
    // add false branch to sceneList
    var scene = this.clone();
    scene.testPath.push(',');
    scene.testPath.push(this.lineNum+1);
    scene.testPath.push('F');
    scene.lineNum = this.lineNum;
    scene.indent = this.indent;
    scene.skipTrueBranch();
    scene.lineNum++;
    scene.resume = function() {
      scene.printLoop(); }
    sceneList.push(scene);
    this.oldIf("true");
  }
  
  //Scene.prototype.choice = function() { this.finished = true;}
  
  var sceneName = "test";
  
  function StartingStats() {};
  for (var i in stats) {
    StartingStats.prototype[i] = stats[i];
  }
  
  var startingStats = new StartingStats();
  debugger;
  
  var scene = new Scene(sceneName, startingStats);
  var originalScene = scene;
  scene.testPath = [];
  scene.loadLines(sceneText);
  
  log("executing");
  scene.execute();
  
  while(scene = sceneList.shift()) {
      log (scene.testPath.join(''));
      //log(sceneList.length);
      scene.resume();
  }
  
  //log(printed.join('\n'));
  var uncovered = [];
  for (var i = 0; i < coverage.length; i++) {
      log("line "+(i+1) +": " +coverage[i]);
      line = trim(originalScene.lines[i]);
      if (!coverage[i] && line && !/\*comment /.test(line)) {
        uncovered.push(i+1);
      }
  }
  
  if (uncovered.length) {
      log("UNCOVERED:");
      log(uncovered.join('\n'));
  }
}

function getContent() {
  return bespin.getContent();
}
window.modified = false;
window.onbeforeunload = function() {
  if (modified) return "If you leave this page, all work will be lost!";
}
</script>
<style>
  body { padding: 20px; font-family: Calibri, Helvetica, Arial; }
  h1 { color: white; border-bottom: 1px solid #ddd; font-size:120%; }
  .bespin { margin: 0; padding: 0; border: 0; height: 600px; border: 10px solid #ddd; -moz-border-radius: 10px; -webkit-border-radius: 10px; }
</style>
</head>
<body>

<h1>Basic ChoiceScript Editor</h1>
<button id="tryIt" onclick="tryIt();">try it!</button>
<div id="editor" class="bespin" data-bespinoptions='{ "settings": { "strictlines": true, "tabsize": 2 }, "stealFocus": true }'>Your majesty, your people are starving in the streets, and threaten revolution.
Our enemies to the west are weak, but they threaten soon to invade.  What will you do?

*choice
  #Make pre-emptive war on the western lands.
    If you can seize their territory, your kingdom will flourish.  But your army's
    morale is low and the kingdom's armory is empty.  How will you win the war?
    *choice
      #Drive the peasants like slaves; if we work hard enough, we'll win.
        Unfortunately, morale doesn't work like that.  Your army soon turns against you
        and the kingdom falls to the western barbarians.
        *finish
      #Appoint charismatic knights and give them land, peasants, and resources.
        Your majesty's people are eminently resourceful.  Your knights win the day,
        but take care: they may soon demand a convention of parliament.
        *finish
      #Steal food and weapons from the enemy in the dead of night.
        A cunning plan.  Soon your army is a match for the westerners; they choose
        not to invade for now, but how long can your majesty postpone the inevitable?
        *finish
  #Beat swords to plowshares and trade food to the westerners for protection.
    The westerners have you at the point of a sword.  They demand unfair terms
    from you.
    *choice
      #Accept the terms for now.
        Eventually, the barbarian westerners conquer you anyway, destroying their
        bread basket, and the entire region starves.
        *finish
      #Threaten to salt our fields if they don't offer better terms.
        They blink.  Your majesty gets a fair price for wheat.
        *finish
  #Abdicate the throne. I have clearly mismanaged this kingdom!
    The kingdom descends into chaos, but you manage to escape with your own hide.
    Perhaps in time you can return to restore order to this fair land.
    *finish
</div>

<script type="text/javascript" 
src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"> </script>
 
<div id="placeholder"></div>

<script>
if (window.CFInstall) CFInstall.check({node: "placeholder"});
</script>


<script>
window.onBespinLoad = function() {
    window.modified = true; // TODO detect dirty
    console.log("this is called when Bespin is loaded");
    bespin = document.getElementById("editor").bespin;
};

</script>
</body>
</html>
